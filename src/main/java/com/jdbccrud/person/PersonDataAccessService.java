package com.jdbccrud.person;

import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.jdbc.support.rowset.SqlRowSet;
import org.springframework.stereotype.Service;

import java.sql.PreparedStatement;
import java.util.List;

@Service
public class PersonDataAccessService implements IPersonDAO{

    private final JdbcTemplate jdbcTemplate;

    public PersonDataAccessService(JdbcTemplate jdbcTemplate){
        this.jdbcTemplate = jdbcTemplate;
    }

    @Override
    public List<Person> selectAllPersons() {
        return null;
    }

    @Override
    public Person selectPersonById() {
        return null;
    }

    @Override
    public Person selectPersonByUsername() {
        return null;
    }

    @Override
    public Person addPerson(Person person) {

        Object[] params = new Object[]{person.getVersion(), person.getUsername(), person.getFirstName(), person.getLastName()};

        String insertSql = """
                INSERT INTO person(version, username, first_name, last_name)
                VALUES (?,?,?,?) RETURNING id;
                """;
        //this version of .update takes in the sql statement and a list of arguments that match to the ?'s
        //int inputId = jdbcTemplate.update(insertSql, person.getVersion(), person.getUsername(), person.getFirstName(), person.getLastName());

        //jdbcTemplate.update has an overloaded method that takes a callback and a KeyHolder as parameters
            //this method gives us the ability to use RETURNING from our postgreSQL statement
            //getting us the autogenerated id from the database without having to do another query with the username
        KeyHolder keyHolder = new GeneratedKeyHolder();

        jdbcTemplate.update( connection -> {
            PreparedStatement ps = connection.prepareStatement(insertSql, PreparedStatement.RETURN_GENERATED_KEYS);
            //we need to set the parameters for the prepared statement manually when using this overloaded method
                for(int i=0; i<params.length; i++){
                    ps.setObject(i+1, params[i]);
                }
                return ps;
        }, keyHolder);

        String newPersonSql = """
                SELECT id, created_date, last_modified_date, first_name, last_name, username, version
                FROM person WHERE id = ?;
                """;
        SqlRowSet rowSet = jdbcTemplate.queryForRowSet(newPersonSql, keyHolder.getKey().longValue());


        if(rowSet.next()){
            return mapRowToPerson(rowSet);
        }

        return null;
    }

    @Override
    public int deletePersonById(int personId) {
        String sql = """
                DELETE FROM person WHERE id = ?;
                """;
        return jdbcTemplate.update(sql, personId);
    }

    @Override
    public int deletePersonByUsername(String username) {
        String sql = """
                DELETE FROM person WHERE username = ?;
                """;
        return jdbcTemplate.update(sql, username);
    }

    @Override
    public Person editPerson() {
        return null;
    }

    private Person mapRowToPerson(SqlRowSet rowSet){
        Person newPerson = new Person();

        newPerson.setId(rowSet.getInt("id"));
        try {
            newPerson.setCreatedDate(rowSet.getTimestamp("created_date").toLocalDateTime());
            newPerson.setLastModifiedDate(rowSet.getTimestamp("last_modified_date").toLocalDateTime());
        } catch (Exception e){
            System.out.println(e.getLocalizedMessage());
        }
        newPerson.setUsername(rowSet.getString("username"));
        newPerson.setFirstName(rowSet.getString("first_name"));
        newPerson.setLastName(rowSet.getString("last_name"));
        newPerson.setVersion(rowSet.getInt("version"));

        return newPerson;
    }
}
